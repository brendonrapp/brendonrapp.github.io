<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | Economy of Effort]]></title>
  <link href="http://www.economyofeffort.com/categories/vim/atom.xml" rel="self"/>
  <link href="http://www.economyofeffort.com/"/>
  <updated>2014-08-11T21:09:01-07:00</updated>
  <id>http://www.economyofeffort.com/</id>
  <author>
    <name><![CDATA[Brendon Rapp]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Beyond Ctrl: Make That Caps Lock Key Useful]]></title>
    <link href="http://www.economyofeffort.com/2014/08/11/beyond-ctrl-remap-make-that-caps-lock-key-useful/"/>
    <updated>2014-08-11T14:19:00-07:00</updated>
    <id>http://www.economyofeffort.com/2014/08/11/beyond-ctrl-remap-make-that-caps-lock-key-useful</id>
    <content type="html"><![CDATA[<p><strong>tl;dr: Supercharge your Caps Lock key by making it Esc when tapped, and Ctrl when held</strong></p>

<p>Caps Lock. A useless key sitting in prime keyboard real estate. Many software developers and power users repurpose the key by remapping it to Control.</p>

<p>After all, on old UNIX terminals, that&rsquo;s exactly what the key to the left of &ldquo;A&rdquo; was:</p>

<p><img src="/media/images/sun-keyboard.png" alt="" /></p>

<p>Replacing the Caps Lock key with Ctrl makes a lot of keyboard shortcuts more convenient. But we need not stop there. Some true Men and Women of Genius came to the realization that, since Ctrl&rsquo;s behavior is based around behind held down (a modifier key) and doesn&rsquo;t do anything when pressed and released, it is possible to make Caps Lock do something <em>else</em> when tapped instead of held. For Vim users, the obvious choice is the Esc key.</p>

<p>We can do this in both Mac OS X and Linux.</p>

<h2>OS X</h2>

<h3>If you want all Ctrl keys to behave like Esc when tapped</h3>

<p>This is the easiest way, and the option I use. (I rarely find myself hitting the normal Ctrl keys anyway.)</p>

<p>First, open System Preferences &ndash;> Keyboard, and click Modifier Keys button. Click the Caps Lock drop-down and set it to Control:</p>

<p><img src="/media/images/osx-remap-esc-key.png" alt="" /></p>

<p>Now, install <a href="https://pqrs.org/osx/karabiner/">Karabiner</a> (formerly known as KeyRemap4MacBook). If you are a Homebrew user, you should check out <a href="https://github.com/caskroom/homebrew-cask">Homebrew Cask</a> and install Karabiner with <code>$ brew cask install karabiner</code></p>

<p>Open Karabiner. Enable the first setting from the screenshot below:</p>

<p><img src="/media/images/karabiner-1.png" alt="" /></p>

<p>The other option I have there, &ldquo;Disable Escape Key&rdquo;, is something I&rsquo;ve done just to get myself in the habit of using the Caps Lock key for Esc. It is not required, it is just an option if you want to help train yourself to use the new key.</p>

<h3>If you only want the Caps Lock key to behave like Esc when tapped</h3>

<p>To do this, we&rsquo;re going to take a slightly different approach. Instead of using OS X&rsquo;s native Caps Lock remapping, we need to use another app, called <a href="https://pqrs.org/osx/karabiner/seil.html">Seil</a> (from the same developer as Karabiner) to remap the Esc key to F19, and then use Karabiner to map F19 to our cool Ctrl/Esc hybrid key.</p>

<p>Install both <a href="https://pqrs.org/osx/karabiner/">Karabiner</a> and <a href="https://pqrs.org/osx/karabiner/seil.html">Seil</a>. (Here again, if you use <a href="https://github.com/caskroom/homebrew-cask">Homebrew Cask</a>, you can do this with <code>$ brew cask install karabiner</code> and <code>$ brew cask install seil</code>)</p>

<p>Open Seil. First, enable the &ldquo;Change Caps Lock&rdquo; option, and set the keycode to 80:</p>

<p><img src="/media/images/seil.png" alt="" /></p>

<p>Next, in Karabiner, enable the &ldquo;F19 for Escape and Control&rdquo; option:</p>

<p><img src="/media/images/karabiner-2.png" alt="" /></p>

<h2>Linux</h2>

<p>To accomplish the same setup in Linux, we need to use a tool called <a href="https://github.com/alols/xcape">xcape</a>.</p>

<p>Build and install xcape per the instructions on the project&rsquo;s Wiki page. One additional step I take after building the app is copying the <code>xcape</code> executable to /usr/local/bin.</p>

<h3>If you only want the Caps Lock key to behave like Esc when tapped</h3>

<p>Add the following lines to your ~/.profile:
<code>
setxkbmap -option 'caps:ctrl_modifier'
xcape -e 'Caps_Lock=Escape'
</code></p>

<h3>If you want all Ctrl keys to behave like Esc when tapped</h3>

<p>Same as above, except we add more arguments to the xcape line:</p>

<p><code>
setxkbmap -option 'caps:ctrl_modifier'
xcape -e 'Caps_Lock=Escape;Control_L=Escape;Control_R=Escape'
</code></p>

<p>Note: If you use some other method of remapping the Caps Lock key to Ctrl (some desktop environments have it as an option in their Keyboard settings, much like OS X), then the Caps_Lock=Escape mapping may not do anything, and you will need to use the Control_L one.</p>

<p>One last little tidbit: Ubuntu 14.10 (&ldquo;Utopic&rdquo;) has xcape <a href="http://packages.ubuntu.com/utopic/xcape">in the universe repos</a>, at least as of the time of this writing. Hopefully it will be included in Ubuntu releases from here on out.</p>

<h2>Now Your Caps Lock Key Rules</h2>

<p>The most useless key on the keyboard (except maybe for Pause, when&rsquo;s the last time you used that?) is now your Swiss Army knife. Vim&rsquo;s keybindings will make a lot more sense now that you can use your pinky the way Bill Joy did on his old ADM3A terminal:</p>

<p><img src="/media/images/adm3a.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert HTML to Haml (and Back Again) Within a Vim Buffer]]></title>
    <link href="http://www.economyofeffort.com/2014/07/20/convert-html-to-haml-within-vim-buffer/"/>
    <updated>2014-07-20T13:36:00-07:00</updated>
    <id>http://www.economyofeffort.com/2014/07/20/convert-html-to-haml-within-vim-buffer</id>
    <content type="html"><![CDATA[<p><a href="http://haml.info/">Haml</a> is great. Haml is the JSON to HTML&rsquo;s XML: all of the garbage and noise stripped away, with only the data and minimal amount of ceremony left.</p>

<p>I use Haml on all Rails projects now, but when dealing with legacy projects, I still encounter HTML/ERb templates.</p>

<p>Using the <a href="https://github.com/haml/html2haml">html2haml</a> command-line tool, I can easily convert HTML/ERb in my Vim buffer into Haml.</p>

<p>The project distributes as a Ruby gem, so installing is accomplished with:</p>

<p><code>bash
$ gem install html2haml
</code></p>

<p>Then, the magic is done with some Vim bindings to feed a buffer or visually-selected chunk of text to the application, and paste its output back into the buffer, replacing the original text.</p>

<p><code>vim
nmap &lt;leader&gt;h :%!html2haml --erb 2&gt; /dev/null&lt;CR&gt;:set ft=haml&lt;CR&gt;
vmap &lt;leader&gt;h :!html2haml --erb 2&gt; /dev/null&lt;CR&gt;
</code></p>

<p>When changing the entire file, I&rsquo;ve also added the command to change the filetype in the Vim buffer, for convenience.</p>

<p>That takes us from HTML/ERb to Haml, but what if we need to go back in the other direction? This is possible with the <a href="https://github.com/elia/haml2erb">haml2erb</a> tool. Unfortunately, this tool is not actively maintained the way html2haml is. For me, on Ruby 2.1.1, it was necessary to install the 0.3.0 prerelease version, as the last official version would not build. Once installed, though, it worked as expected.</p>

<p>We must explicitly indicate which version to install in order to install prerelease gems:</p>

<p><code>bash
$ gem install haml2erb -v '0.3.0.pre.3'
</code></p>

<p>The Vim bindings are much the same as the html2haml ones:</p>

<p><code>vim
nmap &lt;leader&gt;e :%!haml2erb 2&gt; /dev/null&lt;CR&gt;:set ft=eruby&lt;CR&gt;
vmap &lt;leader&gt;e :!haml2erb 2&gt; /dev/null&lt;CR&gt;
</code></p>

<p>I have not used this nearly as much as html2haml, as I&rsquo;m rarely changing layout code from Haml back into HTML. However, the couple of times I have needed to do it, it has worked exactly as expected..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim tricks for Ruby hashes]]></title>
    <link href="http://www.economyofeffort.com/2014/07/09/vim-tricks-for-ruby-hashes/"/>
    <updated>2014-07-09T19:59:00-07:00</updated>
    <id>http://www.economyofeffort.com/2014/07/09/vim-tricks-for-ruby-hashes</id>
    <content type="html"><![CDATA[<p>I have a couple of functions in my .vimrc for manipulating Ruby hashes.</p>

<p>The first one is to convert hashes from Ruby 1.8 style into Ruby 1.9+ style, eg.</p>

<p>```ruby</p>

<h1>before</h1>

<p>:symbol_key => &lsquo;value&rsquo;</p>

<h1>after</h1>

<p>symbol_key: &lsquo;value&rsquo;
```</p>

<p>I create this function for both Normal and Visual modes to allow updating either a selected hash, or the entire file.
```vim
function! RubyHashesAll()
  :%s/:([^ ]<em>)(\s</em>)=>/\1:/ge
endfunction</p>

<p>function! RubyHashesSelected()
  :&lsquo;&lt;,&rsquo;>s/:([^ ]<em>)(\s</em>)=>/\1:/ge
endfunction</p>

<p>nmap <Leader>rhh :call RubyHashesAll()<CR>
vmap <Leader>rhh :call RubyHashesSelected()<CR>
```</p>

<p>Next, I have one for taking a hash and extracting an array of the hash keys.</p>

<p>```ruby</p>

<h1>before</h1>

<p>{ &lsquo;one&rsquo; => two, :three => &lsquo;four&rsquo;, five: 6 }</p>

<h1>after</h1>

<p>[&lsquo;one&rsquo;, :three, :five]
```</p>

<p>Here, I have the command bound only in Visual mode, as I don&rsquo;t see a case where I&rsquo;d want to do this globally.</p>

<p>```vim
function! RubyExtractHashKeys()
  :&lsquo;&lt;,&rsquo;>s/([:&lsquo;&ldquo;]\?[a-zA-Z]+[&rsquo;&rdquo;]\?)\s<em>=>[^,}]+([,}])/\1\2/ge
  :&lsquo;&lt;,&rsquo;>s/([a-zA-Z]+)[:]\s</em>[^,}]+([,}])/:\1\2/ge
  :&lsquo;&lt;,&rsquo;>s/{\s<em>/[/ge
  :&lsquo;&lt;,&rsquo;>s/\s</em>}/]/ge
endfunction</p>

<p>vmap <Leader>rhe :call RubyExtractHashKeys()<CR>
```</p>

<p>The regexes can probably be improved to fix some edge cases, and I&rsquo;m certain there&rsquo;s a way in Vim to make it so that I don&rsquo;t have to define the All and Selected versions of RubyHashes as separate functions. But these do the job for me now, until I reach a higher plane of Vim mastery.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zsh, tmux, vim, and 256 color madness]]></title>
    <link href="http://www.economyofeffort.com/2014/07/04/zsh/"/>
    <updated>2014-07-04T21:20:00-07:00</updated>
    <id>http://www.economyofeffort.com/2014/07/04/zsh</id>
    <content type="html"><![CDATA[<p><strong>tl;dr: You want $TERM to be <code>screen-256color</code> when tmux is running, and you want it to be <code>xterm-256color</code> when tmux is <em>not</em> running. Also, launch tmux with <code>-2</code> argument.</strong></p>

<p>I love <a href="https://wiki.archlinux.org/index.php/Tmux">tmux</a>. It is the primary reason why I switched from using gVim to console vim. I love having a fully terminal-based workflow. It beats switching between a GUI editor app and terminal window any day.</p>

<p>This switch, however, was not without some issues. Here are the solutions to two that I encountered.</p>

<h3>Weirdness with zsh, tmux, and vim</h3>

<h4>Problems:</h4>

<ul>
<li>when $TERM is <code>screen-256color</code> but tmux is <em>not</em> running, zsh will echo your command into the output when you hit Enter:</li>
</ul>


<p><img src="/media/images/screen-256color-no-tmux.png" alt="" /></p>

<p>Notice how the output of the &ldquo;ls&rdquo; and &ldquo;echo&rdquo; commands repeat themselves in the output stream as soon as I switched to <code>screen-256color</code>.</p>

<ul>
<li>when $TERM is <code>xterm-256color</code> while tmux is running, colors will not display properly in Vim:</li>
</ul>


<p style="text-align:left !important;"><code>vim /etc/default/grub</code> while <code>TERM=screen-256color</code>:</p>


<p><img src="/media/images/tmux-vim-screen-256color.png" alt="" /></p>

<p style="text-align:left !important;"><code>vim /etc/default/grub</code> while <code>TERM=xterm-256color</code>:</p>


<p><img src="/media/images/tmux-vim-xterm-256color.png" alt="" /></p>

<h4>Solution:</h4>

<p>In my zsh config (~/.zshrc), I set xterm-256color to be the default TERM, but right after that, added a command that would re-export TERM as screen-256color if tmux is running:</p>

<pre><code>export TERM=xterm-256color
[ -n "$TMUX" ] &amp;&amp; export TERM=screen-256color
</code></pre>

<h3>No Vim colorschemes when tmux is launched by terminal app in place of shell</h3>

<h4>Problem:</h4>

<p>I ran into a specific set of circumstances where my Vim colorscheme would not display.</p>

<p>Terminal applications usually launch a shell by default, but some (like gnome-terminal) have the option of defining a command to be run rather instead of the shell.</p>

<p>If I set this command to <code>tmux</code>, tmux would indeed launch. However, if I then ran Vim, the colorscheme would not display correctly.</p>

<p>However, if I allowed gnome-terminal to launch a shell, and then ran <code>tmux</code> myself from that shell, Vim would display properly within that tmux session.</p>

<h4>Solution:</h4>

<p>I got my clue from <a href="http://stackoverflow.com/questions/10158508/lose-vim-colorscheme-in-tmux-mode">this StackOverflow post</a>. Basically, what is happening is that, when running <code>tmux</code> from within my shell, which is configured for 256 colors, tmux would launch in 256 color mode. But when I had gnome-terminal launch tmux directly, it would not.</p>

<p>The easy way around this was to use the &ldquo;-2&rdquo; argument for tmux, making the command <code>tmux -2</code>.</p>

<p><img src="/media/images/gnome-terminal-auto-tmux.png" alt="" /></p>

<p>With that command in place, tmux launches whenever firing up gnome-terminal, and does so in 256 color mode.</p>
]]></content>
  </entry>
  
</feed>
